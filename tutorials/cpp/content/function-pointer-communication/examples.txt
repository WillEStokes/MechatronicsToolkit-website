<p>This section will provide a step-by-step demonstration of the code needed to implement communication between a slave and master device.</p>

<p><b>Slave Device</b></p>

<p><b>Definitions and declarations:</b></p>

<p>Firstly, we will start by defining the type definitions discussed in the previous section of this tutorial:</p>

<p><textarea class="content-cpp">#include "Wire.h"
#define SLAVE_ADDRESS 0x48

const int LED_PIN = 13; //define LED pin
uint8_t _msgHeaderLength = 3;
uint8_t _error = 0;

// type definitions
typedef void (*messageHandlerFunc)(const void*);

typedef struct {
    uint8_t packetLength;
    uint8_t fid;
    uint8_t error;
} __attribute__((__packed__)) MessageHeader;

typedef struct {
    uint8_t fid;
    messageHandlerFunc replyFunc;
} __attribute__((__packed__)) ComMessage;

typedef struct {
    MessageHeader header;
    uint8_t ledState;
} __attribute__((__packed__)) LedControl;</textarea></p>

<p>Next, we define the <code>fid</code>s that can be invoked on the slave device using an <code>enum</code>. Each <code>fid</code> corresponds to a specific function that is responsible for executing the desired task. In this example, the <code>fid</code>s include <code>FID_LED_ON</code>, <code>FID_LED_OFF</code>, and <code>FID_LED_CONTROL</code>.</p>

<p>Then we declare the function prototypes. These functions correspond to the respective <code>fid</code> and perform the action required for the <code>fid</code> when it is invoked.

<p>And finally, we create the <code>comMessages</code> array which links the <code>fid</code> to its corresponding function using the function pointers defined in the <code>messageHandlerFunc</code>  type definition. Each element in the <code>comMessages</code> array consists of a <code>fid</code> and its corresponding function reference. When an <code>fid</code> is invoked, the slave device uses the linked function reference to execute the corresponding function:</p>

<p><textarea class="content-cpp">// enum
enum FID_LIST {
    FID_LED_ON = 0,
    FID_LED_OFF = 1,
    FID_LED_CONTROL = 2,
};

// functions
void ledOn(const MessageHeader* data);
void ledOff(const MessageHeader* data);
void ledControl(const LedControl* data);

// function id's and reply function references
const ComMessage comMessages[] = {
    {FID_LED_ON, (messageHandlerFunc)&ledOn},
    {FID_LED_OFF, (messageHandlerFunc)&ledOff},
    {FID_LED_CONTROL, (messageHandlerFunc)&ledControl},
};</textarea></p>

<p><b>Setup and loop functions:</b></p>

<p>Now we can perform initialisation tasks, such as begining the communication and setting the LED pin to output in the setup function. We can also start the main loop, which runs continuously listening for incoming data.</p>

<p>In the <code>setup</code> function, we start the communication on the slave device with the defined slave address, and set the receive event function to <code>receiveEvent</code>. We also set the LED pin as an output with and set its initial state to low.</p>

<p>The <code>loop</code> function runs continuously and listens for incoming data by utilising the receive event function that was defined in the <code>setup</code> function. As the communication between the slave and host device is handled through the <code>receiveEvent</code> function, there is no need for any code in the <code>loop</code> function.</p>

<p><textarea class="content-cpp">void setup() {
    Wire.begin(SLAVE_ADDRESS);
    Wire.onReceive(receiveEvent);
    pinMode(LED_PIN, OUTPUT);
    digitalWrite(LED_PIN, LOW);
}

// loop continuously
void loop()
{
}</textarea></p>

<p><b>Helper function:</b></p>

<p>The function <code>receiveEvent</code> is triggered whenever incoming data is received. The code in this function processes the received data as described in the previous section:</p>

<p><textarea class="content-cpp">// receive and process commands from the master
void receiveEvent(int numBytes) {
    static char data[32];
    static MessageHeader* header;
    static byte dataLength = 0;

    // read the incoming data into the buffer
    Wire.readBytes(data, numBytes);

    // set the header pointer to point to the header data of the incoming message
    header = (MessageHeader*)data;
    // calculate the length of the incoming data, excluding the header
    dataLength = numBytes - _msgHeaderLength;

    // retrieve the appropriate comMessage object based on the incoming fid
    const ComMessage* comMessage = &comMessages[header->fid];

    if (comMessage->replyFunc != NULL && dataLength == header->packetLength - _msgHeaderLength) {
        // if the message is valid, call the corresponding reply function
        (*comMessage->replyFunc)((void*)data);
    }
}</textarea></p>

<p><b>User-defined functions:</b></p>

<p>The <code>ledOn</code>, <code>ledOff</code>, and <code>ledControl</code> functions are examples of functions that are invoked by the <code>fid</code>'s that we defined at the top of the script. These functions perform specific actions in response to the corresponding <code>fid</code>.</p>

<p>In these examples, the <code>ledOn</code> function sets the LED pin to HIGH, which turns the LED on. The <code>ledOff</code> function sets the LED pin to LOW, which turns the LED off. The <code>ledControl</code> function controls the LED pin based on the data received. It sets the LED pin to the state specified in the received data. This allows for more fine-grained control of the LED, as the master device can send data specifying the desired state of the LED.</p>

<p><textarea class="content-cpp">// switch LED on (no data)
void ledOn(const MessageHeader* data) {
    digitalWrite(LED_PIN, HIGH);
}

// switch LED off (no data)
void ledOff(const MessageHeader* data) {
    digitalWrite(LED_PIN, LOW);
}

// control the LED pin based on the received data
void ledControl(const LedControl* data) {
    digitalWrite(LED_PIN, data->ledState);
}</textarea></p>

<p><b>Master Device</b></p>

<p>By setting the values in the <code>MessageHeader</code> typedef, which the master transmits to the slave, we can invoke these functions individually.</p>

<p><b>Example 1:</b> In this example <code>invokeFid</code> function on the master, the <code>packetLength</code> is set to 3 and <code>fid</code> is set to 1. The master then sends this data to the slave device by first beginning a transmission to the slave's address, then writing the <code>MessageHeader</code> struct data to the slave, and finally ending the transmission.

The <code>fid</code> value of 1 maps to the <code>ledOn</code> function in the slave, so when the slave receives the <code>MessageHeader</code> struct from the master with an <code>fid</code> of 1, it will execute the <code>ledOn</code> function and turn the LED on:</p>

<p><textarea class="content-cpp">void invokeFid() {
    static MessageHeader message;
    message.packetLength = 3;
    message.fid = 1;
    message.error = 0;
    
    Wire.beginTransmission(SLAVE_ADDRESS);
    Wire.write((char*) &message, 3);
    Wire.endTransmission();

    return;
}</textarea></p>

<p><b>Example 2:</b> In this example, the master sets the <code>packetLength</code> in the <code>MessageHeader</code> to 4 and the <code>fid</code> to 3, which corresponds to the <code>ledControl</code> function. The master then sends two transmissions: the first one to tell the slave which function to invoke, and the second one to set the value that will be passed to the <code>ledControl</code> function, which sets the output value of the <code>LED_PIN</code>. This allows the master to control the LED on the slave device by sending appropriate values to the slave:</p>

<p><textarea class="content-cpp">void invokeFidWithData() {
    static MessageHeader message;
    message.packetLength = 4;
    message.fid = 3;
    message.error = 0;
    
    // first tranmission tells the slave which function to invoke
    Wire.beginTransmission(SLAVE_ADDRESS);
    Wire.write((char*) &message, 3);
    Wire.endTransmission();

    // second tranmission to set the value
    Wire.beginTransmission(K64F_ADDRESS);
    Wire.write((char*) 1, 1);
    Wire.endTransmission();

    return;
}</textarea></p>


